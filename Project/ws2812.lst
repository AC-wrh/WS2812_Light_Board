C51 COMPILER V9.01   WS2812                                                                04/13/2020 15:56:18 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE WS2812
OBJECT MODULE PLACED IN ..\Output\ws2812.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ..\Module\Src\ws2812.c BROWSE INCDIR(..\Module\Inc;..\System\Inc) DEBUG OBJ
                    -ECTEXTEND PRINT(.\ws2812.lst) TABS(2) OBJECT(..\Output\ws2812.obj)

line level    source

   1          /*
   2           * @Description: 
   3           * @version: 
   4           * @Author: Adol
   5           * @Date: 2020-04-11 16:41:33
   6           * @LastEditTime: 2020-04-13 15:56:02
   7           */
   8          #include "core.h"
   9          
  10          unsigned char ws_data_r = 0; //é¢œè‰²å˜é‡0-255 å°±æ˜¯FFä»¥å†…
  11          unsigned char ws_data_g = 0;
  12          unsigned char ws_data_b = 0;
  13          unsigned char ws_data_buf_r[WS2812_QUANTITY];
  14          unsigned char ws_data_buf_g[WS2812_QUANTITY];
  15          unsigned char ws_data_buf_b[WS2812_QUANTITY];
  16          unsigned char ws_rgb_data[3]; // 0 - r, 1 - g, 2 - b
  17          
  18          void dev_ws_send_bit1() //H=0.7us.L=0.6us  æ•°æ®1çš„è¡¨ç¤º   èŠ¯ç‰‡STC15F104W  @ 12MHZ
  19          {                       //1US= 4ä¸ª _nop_();  è¿›ç¨‹åºè¦ç”¨æ‰2ä¸ª_nop_(); å‡ºç¨‹åºç”¨æ‰2ä¸ª_nop_();
  20   1          sda = 1;
  21   1          _nop_();
  22   1          _nop_();
  23   1          _nop_();
  24   1          sda = 0;
  25   1          _nop_();
  26   1      }
  27          
  28          void dev_ws_send_bit0() //H=0.35us.L=0.8us  ==æ•°æ®0çš„è¡¨ç¤º
  29          {
  30   1          sda = 1;
  31   1          _nop_();
  32   1          _nop_();
  33   1          sda = 0;
  34   1          _nop_();
  35   1          _nop_();
  36   1      }
  37          
  38          void dev_ws_send_single_data(unsigned int dat) //å‘é€8ä½ï¼Œ=1é¢—ç¯çš„ä¸€ç§é¢œè‰²ï¼ŒWS2812ç¯æ•°æ®ä¸º
             -24ä¸€ä¸²24ä½äºŒè¿›åˆ¶æ•°â€“æ¯ç§é¢œè‰²8ä½äºŒè¿›åˆ¶æ•°ã€‚
  39          {
  40   1          unsigned char count1; //ä½è®¡æ•°å™¨ï¼Œå•å­—èŠ‚ä¸º8ä½
  41   1          for (count1 = 8; count1 > 0; count1--)
  42   1          {
  43   2              if (dat & 0x80) //å–é«˜ä½å…ˆå‘ï¼Œåˆ™dat & 0x80
  44   2                  dev_ws_send_bit1();
  45   2              else
  46   2                  dev_ws_send_bit0();
  47   2              dat <<= 1; //æ•°æ®å³ç§»ï¼Œä¸‹ä¸€ä¸ªä½çš„æ•°æ®,è‹¥é«˜ä½å…ˆå‘åˆ™dat<<=1
  48   2          }
  49   1      }
  50          
  51          void dev_ws_send_data(unsigned char len, unsigned char *r, unsigned char *g, unsigned char *b) // å…¨éƒ¨å
             -‘é€åŒæ ·çš„æ•°æ®
  52          {
C51 COMPILER V9.01   WS2812                                                                04/13/2020 15:56:18 PAGE 2   

  53   1          unsigned char i;
  54   1      
  55   1          for (i = 0; i < len; i++)
  56   1          {
  57   2              dev_ws_send_single_data(*r);
  58   2              dev_ws_send_single_data(*g);
  59   2              dev_ws_send_single_data(*b);
  60   2              r++;
  61   2              g++;
  62   2              b++;
  63   2          }
  64   1          sda = 0;
  65   1          dev_ws_delayus(70); // é«˜äº50USçš„ä½ç”µå¹³ä¿¡å·=å¤ä½ï¼Œ
  66   1      }
  67          
  68          // LED cycle gradient
  69          // R = FF           G = 0 -> FF         B = 0           yellow  #FFFF00
  70          // R = FF -> 0      G = FF              B = 0           green   #00FF00
  71          // R = 0            G = FF              B = 0 -> FF     cyan    #00FFFF
  72          // R = 0            G = FF -> 0         B = FF          blue    #0000FF
  73          // R = 0 -> FF      G = 0               B = FF          purple  #FF00FF
  74          // R = FF           G = 0               B = FF -> 0     red     #FF0000
  75          
  76          void color_cycle_gradient(unsigned char interval)
  77          {
  78   1          static unsigned char cycle_gradient_flag = 0;
  79   1      
  80   1          switch (cycle_gradient_flag)
  81   1          {
  82   2          case 0: // R = 00 -> FF, G = 0, B = 0   #000000 -> #FF0000
  83   2              ws_data_r += interval;
  84   2      
  85   2              if (ws_data_r == COLOR_MAX)
  86   2              {
  87   3                  cycle_gradient_flag = 1;
  88   3              }
  89   2              break;
  90   2      
  91   2          case 1: // R = FF, G = 0 -> FF, B = 0   #FF0000 -> #FFFF00
  92   2              ws_data_g += interval;
  93   2              if (ws_data_g == COLOR_MAX)
  94   2              {
  95   3                  cycle_gradient_flag = 2;
  96   3              }
  97   2              break;
  98   2      
  99   2          case 2: // R = FF -> 0, G = FF, B = 0   #FFFF00 -> #00FF00
 100   2              ws_data_r -= interval;
 101   2              if (ws_data_r == COLOR_MIN)
 102   2              {
 103   3                  cycle_gradient_flag = 3;
 104   3              }
 105   2              break;
 106   2      
 107   2          case 3: // R = 0, G = FF, B = 0 -> FF   #00FF00 -> #00FFFF
 108   2              ws_data_b += interval;
 109   2              if (ws_data_b == COLOR_MAX)
 110   2              {
 111   3                  cycle_gradient_flag = 4;
 112   3              }
 113   2              break;
 114   2      
C51 COMPILER V9.01   WS2812                                                                04/13/2020 15:56:18 PAGE 3   

 115   2          case 4: // R = 0, G = FF -> 0, B = FF   #00FFFF -> #0000FF
 116   2              ws_data_g -= interval;
 117   2              if (ws_data_g == COLOR_MIN)
 118   2              {
 119   3                  cycle_gradient_flag = 5;
 120   3              }
 121   2              break;
 122   2      
 123   2          case 5: // R = 0 -> FF, G = 0, B = FF   #0000FF -> #FF00FF
 124   2              ws_data_r += interval;
 125   2              if (ws_data_r == COLOR_MAX)
 126   2              {
 127   3                  cycle_gradient_flag = 6;
 128   3              }
 129   2              break;
 130   2      
 131   2          case 6: // R = FF, G = 0, B = 0 -> FF   #FF00FF -> #FF0000
 132   2              ws_data_b -= interval;
 133   2              if (ws_data_b == COLOR_MIN)
 134   2              {
 135   3                  cycle_gradient_flag = 1;
 136   3              }
 137   2              break;
 138   2      
 139   2          default:
 140   2              break;
 141   2          }
 142   1          ws_rgb_data[0] = ws_data_r;
 143   1          ws_rgb_data[1] = ws_data_g;
 144   1          ws_rgb_data[2] = ws_data_b;
 145   1      }
 146          
 147          void reindex_array(unsigned char mode, unsigned char *arr, unsigned char len, unsigned char num)
 148          {
 149   1          unsigned char buf, count;
 150   1      
 151   1          switch (mode)
 152   1          {
 153   2          case 0: //Rotate left
 154   2              while (num--)
 155   2              {
 156   3                  buf = arr[0];
 157   3                  for (count = 0; count < len - 1; count++)
 158   3                  {
 159   4                      arr[count] = arr[count + 1];
 160   4                  }
 161   3                  arr[count] = buf;
 162   3              }
 163   2              break;
 164   2      
 165   2          case 1: //Rotate Right
 166   2              while (num--)
 167   2              {
 168   3                  buf = arr[len - 1];
 169   3                  for (count = len - 1; count > 0; count--)
 170   3                  {
 171   4                      arr[count] = arr[count - 1];
 172   4                  }
 173   3                  arr[0] = buf;
 174   3              }
 175   2              break;
 176   2      
C51 COMPILER V9.01   WS2812                                                                04/13/2020 15:56:18 PAGE 4   

 177   2          default:
 178   2              break;
 179   2          }
 180   1      }
 181          
 182          void get_chase_data(unsigned char chase_quantity, unsigned char chase_interval) //single LED chase
 183          {
 184   1          unsigned char num, chase_data_max[CHASE_QUANTITY];
 185   1          static unsigned char chase_count = 0;
 186   1      
 187   1          for (num = 0; num < chase_quantity; num++)
 188   1          {
 189   2              chase_data_max[num] = WS2812_QUANTITY + num * (chase_interval + 1);
 190   2      
 191   2              if (chase_count >= (CHASE_INTERVAL + 1) * num && chase_count < chase_data_max[num])
 192   2              {
 193   3                  ws_data_buf_r[chase_count - (CHASE_INTERVAL + 1) * num] = ws_rgb_data[0];
 194   3                  ws_data_buf_g[chase_count - (CHASE_INTERVAL + 1) * num] = ws_rgb_data[1];
 195   3                  ws_data_buf_b[chase_count - (CHASE_INTERVAL + 1) * num] = ws_rgb_data[2];
 196   3              }
 197   2              reindex_array(1, ws_rgb_data, sizeof(ws_rgb_data), 1);      // å°†rgbæ•°æ®è¿›è¡Œè°ƒæ¢
 198   2          }
 199   1          if (++chase_count == chase_data_max[chase_quantity - 1])
 200   1          {
 201   2              chase_count = 0;
 202   2          }
 203   1      }
 204          
 205          void PWM_Dimming(unsigned char mode, unsigned char interval, unsigned int speed)
 206          {
 207   1          unsigned char count;
 208   1          // unsigned char chase_data[CHASE_QUANTITY];
 209   1          // static unsigned char chase_count = 0;
 210   1      
 211   1          timing_time = speed;
 212   1      
 213   1          switch (mode)
 214   1          {
 215   2          case MODE_GRADIENT: //timer 25
 216   2              for (count = 0; count < WS2812_QUANTITY - 1; count++)
 217   2              {
 218   3                  ws_data_buf_r[count + 1] = ws_data_buf_r[count];
 219   3                  ws_data_buf_g[count + 1] = ws_data_buf_g[count];
 220   3                  ws_data_buf_b[count + 1] = ws_data_buf_b[count];
 221   3              }
 222   2              color_cycle_gradient(interval);
 223   2              ws_data_buf_r[0] = ws_rgb_data[0];
 224   2              ws_data_buf_g[0] = ws_rgb_data[1];
 225   2              ws_data_buf_b[0] = ws_rgb_data[2];
 226   2              break;
 227   2      
 228   2          case MODE_BOTH_GRADIENT: //timer 25
 229   2              for (count = 0; count < (WS2812_QUANTITY - 1) / 2; count++)
 230   2              {
 231   3                  ws_data_buf_r[count + 1] = ws_data_buf_r[count];
 232   3                  ws_data_buf_g[count + 1] = ws_data_buf_g[count];
 233   3                  ws_data_buf_b[count + 1] = ws_data_buf_b[count];
 234   3      
 235   3                  ws_data_buf_r[23 - (count + 1)] = ws_data_buf_r[23 - count];
 236   3                  ws_data_buf_g[23 - (count + 1)] = ws_data_buf_g[23 - count];
 237   3                  ws_data_buf_b[23 - (count + 1)] = ws_data_buf_b[23 - count];
 238   3              }
C51 COMPILER V9.01   WS2812                                                                04/13/2020 15:56:18 PAGE 5   

 239   2              color_cycle_gradient(interval);
 240   2              ws_data_buf_r[0] = ws_rgb_data[0];
 241   2              ws_data_buf_g[0] = ws_rgb_data[1];
 242   2              ws_data_buf_b[0] = ws_rgb_data[2];
 243   2      
 244   2              ws_data_buf_r[23] = ws_rgb_data[0];
 245   2              ws_data_buf_g[23] = ws_rgb_data[1];
 246   2              ws_data_buf_b[23] = ws_rgb_data[2];
 247   2              break;
 248   2      
 249   2          case MODE_CHASE:
 250   2      
 251   2              for (count = 0; count < WS2812_QUANTITY - 1; count++)
 252   2              {
 253   3                  ws_data_buf_r[count] = 0xff;
 254   3                  ws_data_buf_g[count] = 0xff;
 255   3                  ws_data_buf_b[count] = 0xff;
 256   3              }
 257   2              color_cycle_gradient(interval);
 258   2              get_chase_data(CHASE_QUANTITY, CHASE_INTERVAL);
 259   2      
 260   2              break;
 261   2      
 262   2          default:
 263   2              break;
 264   2          }
 265   1      
 266   1          dev_ws_send_data(WS2812_QUANTITY, ws_data_buf_r, ws_data_buf_g, ws_data_buf_b);
 267   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    865    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     80      26
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
